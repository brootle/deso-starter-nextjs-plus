"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[221],{3656:(e,t,i)=>{i.d(t,{l:()=>ed});var s,r,a,n,h,o,l,c,f,u,d,y,p,m,w,v,g,b,E,K,S,k,I,P,T,x,N,A,D,R,C,_,O,M,B,H,U,G,L,W,$,j,F,Y,J,V,q=i(8512),z=i(7773),Z=i(5849),Q=i(9435),X=i(5607),ee=i(3099),et=i(6861),ei=i(1700),es=i(7267),er=i(6755),ea=i(7905),en=i(4052),eh=i(1974),eo=i(7034),el=i(8623),ec=function(e,t,i,s,r){if("m"===s)throw TypeError("Private method is not writable");if("a"===s&&!r)throw TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!r:!t.has(e))throw TypeError("Cannot write private member to an object whose class did not declare it");return"a"===s?r.call(e,i):r?r.value=i:t.set(e,i),i},ef=function(e,t,i,s){if("a"===i&&!s)throw TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!s:!t.has(e))throw TypeError("Cannot read private member from an object whose class did not declare it");return"m"===i?s:"a"===i?s.call(e):s?s.value:t.get(e)};class eu{constructor({resolve:e,reject:t,event:i}){s.set(this,void 0),r.set(this,void 0),Object.defineProperty(this,"event",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"status",{enumerable:!0,configurable:!0,writable:!0,value:"pending"}),ec(this,r,t,"f"),ec(this,s,e,"f"),this.event=i}resolve(e){return this.status="settled",ef(this,s,"f").call(this,e)}reject(e){return this.status="settled",ef(this,r,"f").call(this,e)}}s=new WeakMap,r=new WeakMap;class ed{get nodeURI(){return ef(this,c,"f")}get transactionSpendingLimitOptions(){return ef(this,y,"f")}constructor(e,t){a.add(this),n.set(this,void 0),h.set(this,void 0),o.set(this,es.uM),l.set(this,"mainnet"),c.set(this,es.Q4),f.set(this,void 0),u.set(this,void 0),d.set(this,void 0),y.set(this,es.Hf),p.set(this,""),m.set(this,"ES256"),w.set(this,"default-key"),v.set(this,void 0),g.set(this,[]),b.set(this,!1),E.set(this,void 0),K.set(this,void 0),S.set(this,void 0),k.set(this,!1),I.set(this,!1),P.set(this,3650),ec(this,n,e,"f"),ec(this,h,t,"f"),ec(this,E,void 0!==e.location,"f"),ec(this,S,globalThis.localStorage,"f"),ef(this,E,"f")&&ef(this,n,"f").location.search&&this.handleRedirectURI(ef(this,n,"f").location.search)}configure({identityURI:e=es.uM,network:t="mainnet",nodeURI:i="https://node.deso.org",spendingLimitOptions:s=es.Hf,redirectURI:r,jwtAlgorithm:a="ES256",appName:n="",storageProvider:h,identityPresenter:f,showSkip:d}){ec(this,o,e,"f"),ec(this,l,t,"f"),ec(this,c,i,"f"),ec(this,u,r,"f"),ec(this,m,a,"f"),ec(this,p,n,"f"),ec(this,K,f,"f"),ec(this,k,!!d,"f"),h&&ec(this,S,h,"f"),!ef(this,b,"f")&&(ec(this,y,(0,eh.b)(s),"f"),ef(this,S,"f")&&this.refreshDerivedKeyPermissions()),ec(this,b,!0,"f")}async subscribe(e){ef(this,g,"f").push(e);let t=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:el.s.SUBSCRIBE,...t}))}unsubscribe(e){ec(this,g,ef(this,g,"f").filter(t=>t!==e),"f")}snapshot(){return ef(this,a,"m",T).call(this)}async login({getFreeDeso:e=!0,derivedKeyLogin:t=!0}={}){let i;if(!ef(this,S,"f"))throw Error("No storage provider available. Did you forget to configure a custom storageProvider?");let s=el.s.LOGIN_START,r=await ef(this,a,"m",T).call(this);if(ef(this,g,"f").forEach(e=>e({event:s,...r})),!t)return new Promise((t,i)=>{ec(this,d,new eu({resolve:t,reject:i,event:s}),"f"),ef(this,a,"m",F).call(this,"log-in",{accessLevelRequest:2,getFreeDeso:e,showSkip:ef(this,k,"f")})});let n=await ef(this,S,"f").getItem(es.rS.loginKeyPair);if(n)i=JSON.parse(n).publicKey;else{let e=(0,er._n)();i=(0,er.gS)(e.public,{network:ef(this,l,"f")}),await ef(this,S,"f").setItem(es.rS.loginKeyPair,JSON.stringify({publicKey:i,seedHex:e.seedHex}))}return await new Promise((t,n)=>{ec(this,d,new eu({resolve:t,reject:n,event:s}),"f");let h=[];r.currentUser?.primaryDerivedKey&&h.push(r.currentUser?.publicKey);let o=r.alternateUsers??{};Object.keys(o).forEach(e=>{o[e]?.primaryDerivedKey&&h.push(e)});let l={derive:!0,derivedPublicKey:i,transactionSpendingLimitResponse:ef(this,y,"f"),expirationDays:ef(this,P,"f"),showSkip:ef(this,k,"f"),...h.length&&{authenticatedUsers:h.join(",")}};e&&(l.getFreeDeso=!0),ef(this,a,"m",F).call(this,"derive",l)})}async loginWithAutoDerive(e,{derivedSeedHex:t}={}){let i=el.s.LOGIN_START,s=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:i,...s}));let r=(0,er._n)(e),n=(0,er._n)(t),h=(0,er.gS)(n.public,{network:ef(this,l,"f")});await ef(this,S,"f")?.setItem(es.rS.loginKeyPair,JSON.stringify({publicKey:h,seedHex:n.seedHex}));let o=await (0,ea.a)(r,n,ef(this,y,"f"),ef(this,P,"f"),ef(this,l,"f"));return new Promise((e,t)=>{ec(this,d,new eu({resolve:e,reject:t,event:i}),"f"),ec(this,I,!0,"f"),ef(this,a,"m",H).call(this,{service:"identity",method:"derive",payload:o})})}async logout(){let e=el.s.LOGOUT_START,t=await ef(this,a,"m",T).call(this);return ef(this,g,"f").forEach(i=>i({event:e,...t})),new Promise((t,i)=>{let s=ef(this,a,"m",x).call(this),r=s=>{ec(this,d,new eu({resolve:t,reject:i,event:e}),"f"),s?ef(this,a,"m",F).call(this,"logout",{publicKey:s}):ef(this,d,"f").reject(Error("cannot logout without an active public key"))};"string"==typeof s||null===s?r(s):s?.then(r)})}async signTx(e){let{primaryDerivedKey:t}=await ef(this,a,"m",A).call(this)??{};if(!t?.derivedSeedHex)throw Error("Cannot sign transaction without a derived seed hex");return await (0,er.qS)(e,t.derivedSeedHex,{isDerivedKey:!0})}async submitTx(e){let t=await ef(this,h,"f").post(`${ef(this,c,"f")}/api/v0/submit-transaction`,{TransactionHex:e});return this.refreshDerivedKeyPermissions(),t}async submitAtomicTx(e,t){let i=await ef(this,h,"f").post(`${ef(this,c,"f")}/api/v0/submit-atomic-transaction`,{IncompleteAtomicTransactionHex:e,SignedInnerTransactionsHex:t});return this.refreshDerivedKeyPermissions(),i}async signAndSubmit(e){return await this.submitTx(await this.signTx(e.TransactionHex))}async signAndSubmitAtomic(e){let t=[];for(let i=0;i<e.InnerTransactionHexes.length;i++){let s=await this.signTx(e.InnerTransactionHexes[i]);t.push(s)}return await this.submitAtomicTx(e.TransactionHex,t)}async signAndSubmitTx(e){try{let t=await e();return await this.submitTx(await this.signTx(t.TransactionHex))}catch(t){if(t?.message?.includes("RuleErrorDerivedKeyNotAuthorized")){let{primaryDerivedKey:t}=await ef(this,a,"m",A).call(this)??{};if(null==t)throw Error("Cannot authorize derived key without a logged in user");await ef(this,a,"m",M).call(this,t.publicKeyBase58Check);let i=await e();return await this.submitTx(await this.signTx(i.TransactionHex))}throw t}}async encryptMessage(e,t){let{primaryDerivedKey:i}=await ef(this,a,"m",A).call(this)??{};if(!i?.messagingPrivateKey)throw Error("Cannot encrypt message without a private messaging key");return await (0,er.ng)(i.messagingPrivateKey,e,t)}async decryptMessage(e,t){let{primaryDerivedKey:i,publicKey:s}=await ef(this,a,"m",A).call(this)??{};if(!(i?.messagingPrivateKey&&s))throw Error("Cannot decrypt messages without a logged in user");let r=e.SenderInfo.OwnerPublicKeyBase58Check===s&&(e.SenderInfo.AccessGroupKeyName===ef(this,w,"f")||!e.SenderInfo.AccessGroupKeyName),n="",h="";switch(e.ChatType){case ei.He.DM:if(e.MessageInfo?.ExtraData?.unencrypted)n=ep(e.MessageInfo.EncryptedText);else try{n=await ef(this,a,"m",V).call(this,s,i.messagingPrivateKey,e,r)}catch(e){h=e?.toString()??"Could not decrypt direct message"}break;case ei.He.GROUPCHAT:try{n=await ef(this,a,"m",J).call(this,t,e)}catch(e){h=e?.toString()??"Could not decrypt group message"}break;default:throw Error(`unsupported chat type: ${e.ChatType}`)}return{...e,DecryptedMessage:n,IsSender:r,error:h}}async decryptAccessGroupKeyPair(e){let{primaryDerivedKey:t}=await ef(this,a,"m",A).call(this)??{};if(!t?.messagingPrivateKey)throw Error("Cannot encrypt message without a private messaging key");let i=await (0,er.Yc)(t.messagingPrivateKey,e);return(0,er._n)(i)}async accessGroupStandardDerivation(e){let{primaryDerivedKey:t}=await ef(this,a,"m",A).call(this)??{};if(!t?.messagingPrivateKey)throw Error("Cannot derive access group without a messaging key");let i=(0,er.kg)(t?.messagingPrivateKey,e),s=(0,er.gS)(i.public,{network:ef(this,l,"f")});return{AccessGroupPrivateKeyHex:i.seedHex,AccessGroupPublicKeyBase58Check:s,AccessGroupKeyName:e}}async jwt(){let{primaryDerivedKey:e}=await ef(this,a,"m",A).call(this)??{};if(!e?.derivedSeedHex)throw Error("Cannot sign jwt without a derived seed hex");return await (0,er.WW)(e.derivedSeedHex,ef(this,m,"f"),{derivedPublicKeyBase58Check:e.derivedPublicKeyBase58Check,expiration:600})}async getDeso(){let e=el.s.GET_FREE_DESO_START,t=await ef(this,a,"m",T).call(this);return ef(this,g,"f").forEach(i=>i({event:e,...t})),await new Promise((t,i)=>{let s=ef(this,a,"m",x).call(this),r=s=>{if(ec(this,d,new eu({resolve:t,reject:i,event:e}),"f"),!s){ef(this,d,"f").reject(Error("Cannot get free deso without a logged in user"));return}ef(this,a,"m",F).call(this,"get-deso",{publicKey:s,getFreeDeso:!0,showSkip:ef(this,k,"f")})};"string"==typeof s||null===s?r(s):s?.then(r)})}async verifyPhoneNumber(){let e=el.s.VERIFY_PHONE_NUMBER_START,t=await ef(this,a,"m",T).call(this);return ef(this,g,"f").forEach(i=>i({event:e,...t})),await new Promise((t,i)=>{let s=ef(this,a,"m",x).call(this),r=s=>{ec(this,d,new eu({resolve:t,reject:i,event:e}),"f"),s||ef(this,d,"f").reject(Error("Cannon verify phone number without an active user")),ef(this,a,"m",F).call(this,"verify-phone-number",{public_key:s,showSkip:ef(this,k,"f")})};"string"==typeof s||null===s?r(s):s?.then(r)})}setActiveUser(e){let t=ef(this,a,"m",_).call(this,e);if("function"==typeof t?.then)return t.then(()=>this.snapshot().then(e=>{this.refreshDerivedKeyPermissions(),ef(this,g,"f").forEach(t=>t({event:el.s.CHANGE_ACTIVE_USER,...e}))}));let i=ef(this,a,"m",T).call(this);this.refreshDerivedKeyPermissions(),ef(this,g,"f").forEach(e=>e({event:el.s.CHANGE_ACTIVE_USER,...i}))}async refreshDerivedKeyPermissions(){let{primaryDerivedKey:e}=await ef(this,a,"m",A).call(this)??{};if(null!=e&&!1!==e.derivedKeyRegistered)try{let t=await ef(this,h,"f").get(`${ef(this,c,"f")}/api/v0/get-single-derived-key/${e.publicKeyBase58Check}/${e.derivedPublicKeyBase58Check}`);await ef(this,a,"m",W).call(this,e.publicKeyBase58Check,{primaryDerivedKey:{...e,transactionSpendingLimits:t.DerivedKey?.TransactionSpendingLimit??null,IsValid:!!t.DerivedKey?.IsValid}})}catch(e){"localhost"===ef(this,n,"f").location.hostname&&console.error(e)}}hasPermissions(e){if(0===Object.keys(e).length)throw Error("You must pass at least one permission to check");let t=ef(this,a,"m",N).call(this),i=(t,i)=>{if(!(t&&i))return!1;let{primaryDerivedKey:s}=t[i]??{};return!!(s?.IsValid&&s?.derivedKeyRegistered!==!1&&s?.transactionSpendingLimits)&&(0,eh.W)(e,s.transactionSpendingLimits)};return"function"==typeof t?.then?Promise.all([t,ef(this,a,"m",x).call(this)]).then(([e,t])=>i(e,t)):i(t,ef(this,a,"m",x).call(this))}async requestPermissions(e){let{primaryDerivedKey:t}=await ef(this,a,"m",A).call(this)??{};if(null==t)throw Error("Cannot request permissions without a logged in user");let{publicKeyBase58Check:i,derivedPublicKeyBase58Check:s}=t;return await this.derive(e,{ownerPublicKey:i,derivedPublicKey:s,expirationDays:ef(this,P,"f")})}async derive(e,t){if(!ef(this,S,"f"))throw Error("No storage provider available.");ef(this,S,"f").removeItem(es.rS.loginKeyPair);let i=el.s.REQUEST_PERMISSIONS_START,s=await ef(this,a,"m",T).call(this);return ef(this,g,"f").forEach(e=>e({event:i,...s})),await new Promise((s,r)=>{ec(this,d,new eu({resolve:s,reject:r,event:i}),"f");let n={derive:!0,...!!t?.derivedPublicKey&&{derivedPublicKey:t.derivedPublicKey},...!!t?.expirationDays&&{expirationDays:t.expirationDays},...!!t?.deleteKey&&{deleteKey:t.deleteKey},...!!t?.ownerPublicKey&&{publicKey:t.ownerPublicKey},transactionSpendingLimitResponse:(0,eh.b)(e),showSkip:ef(this,k,"f")};ef(this,a,"m",F).call(this,"derive",n)})}desoAddressToEthereumAddress(e){let t=(0,er.pV)(e).slice(1),i=z.Wp.bytesToHex((0,q.lY)(t)).slice(24),s=z.Wp.bytesToHex((0,q.lY)(i));return Array.from(i).reduce((e,t,i)=>e+(parseInt(s[i],16)>=8?t.toUpperCase():t),"0x")}async ethereumAddressToDesoAddress(e){if(!/^0x[a-fA-F0-9]{40}$/.test(e))throw Error("Invalid Ethereum address");let t=await ef(this,a,"m",R).call(this,e);if(0===t.length)throw Error(`ETH address must sign at least one transaction in order to recover its public key: ${e}`);let i=es.cU[ef(this,l,"f")],s="";for(let{hash:r}of t)try{let t;let n=(await ef(this,a,"m",D).call(this,{Method:"eth_getTransactionByHash",Params:[r],UseNetwork:i})).result,h=Z.FU({r:n.r,s:n.s,v:parseInt(n.v,16)});switch(parseInt(n.type,16)){case 0:t={gasPrice:n.gasPrice,gasLimit:n.gas,value:n.value,nonce:parseInt(n.nonce,16),data:n.input,chainId:parseInt(n.chainId?n.chainId:"goerli"===i?"0x5":"0x1",16),to:n.to};break;case 2:t={gasLimit:n.gas,value:n.value,nonce:parseInt(n.nonce,16),data:n.input,chainId:parseInt(n.chainId?n.chainId:"goerli"===i?"0x5":"0x1",16),to:n.to,type:2,maxFeePerGas:n.maxFeePerGas,maxPriorityFeePerGas:n.maxPriorityFeePerGas};break;default:throw Error("Unsupported txn type")}let o=await Q.k_(t),l=X.lK(o),c=ee.S(l),f=Z.k9(c),u=et.jL(f,h),d=X.Kt(u);if(d.toLowerCase()!==e.toLowerCase())throw Error(`recovered address ${d} does not match expected address ${e}`);s=u.slice(2);break}catch(e){console.error(`error recovering public key from txn: ${r}`,e)}if(!s)throw Error(`failed to recover public key for eth address: ${e}`);let r=z.bR.fromHex(s).toRawBytes(!0);return(0,er.gS)(r,{network:ef(this,l,"f")})}handleRedirectURI(e){let t=new URLSearchParams(e.split("?")[1]);if(t.get("service")===es.Ns){let e=(0,eo.U)(t);ef(this,n,"f").history?.replaceState({},"",ef(this,n,"f").location.pathname),ef(this,a,"m",H).call(this,e)}setTimeout(()=>{ef(this,b,"f")||this.refreshDerivedKeyPermissions()},50)}}n=new WeakMap,h=new WeakMap,o=new WeakMap,l=new WeakMap,c=new WeakMap,f=new WeakMap,u=new WeakMap,d=new WeakMap,y=new WeakMap,p=new WeakMap,m=new WeakMap,w=new WeakMap,v=new WeakMap,g=new WeakMap,b=new WeakMap,E=new WeakMap,K=new WeakMap,S=new WeakMap,k=new WeakMap,I=new WeakMap,P=new WeakMap,a=new WeakSet,T=function(){let e=ef(this,a,"m",N).call(this),t=(e,t)=>{let i=t&&e&&(e[t]??null),s=e&&Object.keys(e).reduce((i,s)=>(s!==t&&(i[s]=e?.[s]),i),{});return{currentUser:i,alternateUsers:Object.keys(s??{})?.length?s:null}};return"function"==typeof e?.then?Promise.all([e,ef(this,a,"m",x).call(this)]).then(e=>t(...e)):t(e,ef(this,a,"m",x).call(this))},x=function(){if(!ef(this,S,"f"))throw Error("No storage provider available.");let e=ef(this,S,"f").getItem(es.rS.activePublicKey);return e},N=function(){if(!ef(this,S,"f"))throw Error("No storage provider available.");let e=ef(this,S,"f").getItem(es.rS.identityUsers);return"string"==typeof e||null===e?e&&JSON.parse(e):e.then(e=>e&&JSON.parse(e))},A=function(){let e=ef(this,a,"m",x).call(this);if("string"==typeof e||null===e){if(!e)return null;let t=ef(this,a,"m",N).call(this);return t?.[e]??null}return Promise.all([e,ef(this,a,"m",N).call(this)]).then(([e,t])=>e?t?.[e]??null:null)},D=async function(e){return await ef(this,h,"f").post(`${ef(this,c,"f")}/api/v0/query-eth-rpc`,e)},R=async function(e){if(!/^0x[a-fA-F0-9]{40}$/.test(e))throw Error("Invalid Ethereum address");let t=await ef(this,h,"f").get(`${ef(this,c,"f")}/api/v0/get-eth-transactions-for-eth-address/${e}?eth_network=${es.cU[ef(this,l,"f")]}`);if("1"!==t.status||!t.message.startsWith("OK"))throw Error(`Error fetching ETH transactions for address ${e}: ${t.message}`);return t.result.filter(t=>t.from.toLowerCase()===e.toLowerCase())},C=async function(e){return await ef(this,h,"f").post(`${ef(this,c,"f")}/api/v0/authorize-derived-key`,e)},_=function(e){let t=ef(this,a,"m",N).call(this),i=(e,t)=>{if(!(t&&e?.[t]))throw Error(`No user found for public key. Stored users: ${JSON.stringify(e??{})}`);if(!ef(this,S,"f"))throw Error("No storage provider available. Did you forget to configure a storageProvider?");return ef(this,S,"f").setItem(es.rS.activePublicKey,t)};return"function"==typeof t?.then?t.then(t=>i(t,e)):i(t,e)},O=function(e){if(e?.message?.indexOf("Total input 0 is not sufficient to cover the spend amount")>=0)return en.L.NO_MONEY},M=async function(e){let t=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:el.s.AUTHORIZE_DERIVED_KEY_START,...t}));let i=await ef(this,a,"m",N).call(this),s=i?.[e]?.primaryDerivedKey;if(null==s)throw Error(`No primary derived key found for user ${e}`);let r=ef(this,p,"f").trim(),h=r.length>0?r:ef(this,n,"f").location?.hostname??"unknown",o=await ef(this,a,"m",C).call(this,{OwnerPublicKeyBase58Check:s.publicKeyBase58Check,DerivedPublicKeyBase58Check:s.derivedPublicKeyBase58Check,ExpirationBlock:s.expirationBlock,AccessSignature:s.accessSignature,DeleteKey:!1,DerivedKeySignature:!1,MinFeeRateNanosPerKB:1e3,TransactionSpendingLimitHex:s.transactionSpendingLimitHex,Memo:h,AppName:ef(this,p,"f"),TransactionFees:[],ExtraData:{}}),l=await this.signTx(o.TransactionHex),c=await this.submitTx(l),f=await ef(this,a,"m",T).call(this);return ef(this,g,"f").forEach(e=>e({event:el.s.AUTHORIZE_DERIVED_KEY_END,...f})),c},B=async function(e){e.origin===ef(this,o,"f")&&e.data.service===es.Ns&&null!==e.source&&("initialize"===e.data.method?e.source.postMessage({id:e.data.id,service:es.Ns,payload:{appName:ef(this,p,"f")}},ef(this,o,"f")):(await ef(this,a,"m",H).call(this,e.data),ef(this,f,"f")?.close(),null!=ef(this,v,"f")&&ef(this,n,"f").removeEventListener("message",ef(this,v,"f")),ec(this,v,void 0,"f")))},H=async function({method:e,payload:t={}}){switch(e){case"derive":await ef(this,a,"m",L).call(this,t).then(async e=>{let t=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:ef(this,d,"f")?.event===el.s.LOGIN_START?el.s.LOGIN_END:el.s.REQUEST_PERMISSIONS_END,...t})),ef(this,d,"f")?.resolve(e)}).catch(async e=>{let i=await ef(this,a,"m",A).call(this);if((ef(this,k,"f")||ef(this,I,"f"))&&e.message.indexOf("RuleErrorInsufficientBalance")>=0&&null!=i)await ef(this,a,"m",W).call(this,i.publicKey,{primaryDerivedKey:{...i.primaryDerivedKey,...t,derivedKeyRegistered:!1}}),await ef(this,S,"f").setItem(es.rS.activePublicKey,i.publicKey);else if(ef(this,d,"f")?.event===el.s.LOGIN_START&&null!=i){if(ef(this,a,"m",G).call(this,i.publicKey),!ef(this,S,"f"))throw Error("No storage provider available.");await ef(this,S,"f").removeItem(es.rS.activePublicKey)}let s=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:el.s.AUTHORIZE_DERIVED_KEY_FAIL,...s})),ef(this,d,"f")?.reject(ef(this,a,"m",Y).call(this,e))});break;case"login":await ef(this,a,"m",U).call(this,t).then(()=>{ef(this,d,"f")?.resolve(t)}).catch(e=>{ef(this,d,"f")?.reject(ef(this,a,"m",Y).call(this,e))});break;default:throw Error(`Unknown method: ${e}`)}},U=async function(e){if(!ef(this,S,"f"))throw Error("No storage provider available.");let t=await ef(this,a,"m",x).call(this);if(await ef(this,S,"f").removeItem(es.rS.loginKeyPair),e.publicKeyAdded){if(e.publicKeyAdded&&!e.signedUp&&e.publicKeyAdded===t){let t;let i=ef(this,d,"f")?.event;if(i===el.s.GET_FREE_DESO_START)t=el.s.GET_FREE_DESO_END;else if(i===el.s.VERIFY_PHONE_NUMBER_START)t=el.s.VERIFY_PHONE_NUMBER_END;else if(i===el.s.LOGIN_START)t=el.s.LOGIN_END;else throw Error(`unexpected identity event: ${i}`);ef(this,a,"m",M).call(this,e.publicKeyAdded).then(async()=>{ef(this,d,"f")?.resolve(e);let i=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:t,...i}))}).catch(async e=>{let t=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:el.s.AUTHORIZE_DERIVED_KEY_FAIL,...t})),ef(this,d,"f")?.reject(ef(this,a,"m",Y).call(this,e))})}else if(e.publicKeyAdded){await ef(this,a,"m",W).call(this,e.publicKeyAdded,e.users[e.publicKeyAdded]),ef(this,d,"f")?.resolve(e),await ef(this,S,"f").setItem(es.rS.activePublicKey,e.publicKeyAdded);let t=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:el.s.LOGIN_END,...t}))}else console.warn("unhandled identity login payload",e)}else{if(!t)throw Error("No active public key found");await ef(this,S,"f").removeItem(es.rS.activePublicKey),await ef(this,a,"m",G).call(this,t);let i=await ef(this,a,"m",T).call(this);ef(this,g,"f").forEach(e=>e({event:el.s.LOGOUT_END,...i})),ef(this,d,"f")?.resolve(e)}},G=async function(e){if(!ef(this,S,"f"))throw Error("No storage provider is available.");let t=await ef(this,S,"f").getItem(es.rS.identityUsers);if(t){let i=JSON.parse(t);delete i[e],0===Object.keys(i).length?await ef(this,S,"f").removeItem(es.rS.identityUsers):await ef(this,S,"f").setItem(es.rS.identityUsers,JSON.stringify(i))}},L=async function(e){let{primaryDerivedKey:t}=await ef(this,a,"m",A).call(this)??{};if(""===e.derivedSeedHex&&delete e.derivedSeedHex,!ef(this,S,"f"))throw Error("No storage provider is available.");let i=await ef(this,S,"f").getItem(es.rS.loginKeyPair);if(await ef(this,S,"f").removeItem(es.rS.loginKeyPair),null!=t&&t.publicKeyBase58Check===e.publicKeyBase58Check&&t.derivedPublicKeyBase58Check===e.derivedPublicKeyBase58Check)return await ef(this,a,"m",W).call(this,e.publicKeyBase58Check,{primaryDerivedKey:{...t,...e}}),await ef(this,a,"m",M).call(this,e.publicKeyBase58Check).then(async()=>{let{primaryDerivedKey:t}=await ef(this,a,"m",A).call(this)??{};return await ef(this,a,"m",W).call(this,e.publicKeyBase58Check,{primaryDerivedKey:{...t,derivedKeyRegistered:!0}}),e});let[s,r]=await Promise.all([ef(this,a,"m",N).call(this),ef(this,a,"m",x).call(this)]);if(s?.[e.publicKeyBase58Check]!=null&&e.publicKeyBase58Check!==r)await ef(this,a,"m",_).call(this,e.publicKeyBase58Check),this.refreshDerivedKeyPermissions();else if(i){let{seedHex:s}=JSON.parse(i);return await ef(this,a,"m",W).call(this,e.publicKeyBase58Check,{primaryDerivedKey:{...t,...e,derivedSeedHex:s}}),await ef(this,S,"f").setItem(es.rS.activePublicKey,e.publicKeyBase58Check),await ef(this,a,"m",M).call(this,e.publicKeyBase58Check).then(async()=>{let{primaryDerivedKey:t}=await ef(this,a,"m",A).call(this)??{};return await ef(this,a,"m",W).call(this,e.publicKeyBase58Check,{primaryDerivedKey:{...t,derivedSeedHex:s,derivedKeyRegistered:!0}}),{...e,publicKeyAdded:e.publicKeyBase58Check}})}return e},W=async function(e,t={}){if(!ef(this,S,"f"))throw Error("No storage provider is available.");let i=await ef(this,S,"f").getItem(es.rS.identityUsers);if(i){let s=JSON.parse(i);s[e]?s[e]={publicKey:e,...s[e],...t}:s[e]={publicKey:e,...t},await ef(this,S,"f").setItem(es.rS.identityUsers,JSON.stringify(s))}else await ef(this,S,"f").setItem(es.rS.identityUsers,JSON.stringify({[e]:{publicKey:e,...t}}))},$=function(e){let t=new URLSearchParams(Object.entries(e).reduce((e,[t,i])=>(e[t]="object"==typeof i&&null!==i?encodeURIComponent(JSON.stringify(i)):i,e),{}));return"testnet"===ef(this,l,"f")&&t.append("testnet","true"),ef(this,u,"f")&&t.append("redirect_uri",ef(this,u,"f")),t.append("subAccounts","true"),t},j=function(e){null!=ef(this,f,"f")&&ef(this,f,"f").close();let t=ef(this,n,"f").outerHeight/2+ef(this,n,"f").screenY-500,i=ef(this,n,"f").outerWidth/2+ef(this,n,"f").screenX-400;ec(this,f,ef(this,n,"f").open(e,void 0,`toolbar=no, width=800, height=1000, top=${t}, left=${i}`),"f");let s=setInterval(()=>{ef(this,f,"f")?.closed&&(clearInterval(s),ef(this,d,"f")?.status==="pending"&&ef(this,d,"f").reject(new ey("Identity window was closed without any user interaction.",en.L.IDENTITY_WINDOW_CLOSED)))},300)},F=function(e,t){let i=ef(this,a,"m",$).call(this,t),s=`${ef(this,o,"f")}/${e.replace(/^\//,"")}?${i}`;if("function"==typeof ef(this,K,"f")){ef(this,K,"f").call(this,s);return}if("function"!=typeof ef(this,n,"f").open)throw Error("No identity presenter is available. Did you forget to configure a custom identityPresenter?");i.get("redirect_uri")?ef(this,n,"f").location.href=s:(null!=ef(this,v,"f")&&ef(this,n,"f").removeEventListener("message",ef(this,v,"f")),ec(this,v,ef(this,a,"m",B).bind(this),"f"),ef(this,n,"f").addEventListener("message",ef(this,v,"f")),ef(this,a,"m",j).call(this,s))},Y=function(e){let t=ef(this,a,"m",O).call(this,e);return t?new ey(e.message,t,e):e},J=async function(e,t){let i=e.find(e=>e.AccessGroupKeyName===t.RecipientInfo.AccessGroupKeyName&&e.AccessGroupOwnerPublicKeyBase58Check===t.RecipientInfo.OwnerPublicKeyBase58Check&&e.AccessGroupMemberEntryResponse);if(!i?.AccessGroupMemberEntryResponse?.EncryptedKey)throw Error("access group key not found for group message");let s=await this.decryptAccessGroupKeyPair(i.AccessGroupMemberEntryResponse.EncryptedKey);return await (0,er.L2)(s.seedHex,t.SenderInfo.AccessGroupPublicKeyBase58Check,t.MessageInfo.EncryptedText)},V=async function(e,t,i,s){let r=s?i.SenderInfo:i.RecipientInfo;if(i?.MessageInfo?.ExtraData&&i.MessageInfo.ExtraData.unencrypted)return ep(i.MessageInfo.EncryptedText);{let s=i.RecipientInfo.OwnerPublicKeyBase58Check===e&&i.RecipientInfo.AccessGroupKeyName===r.AccessGroupKeyName?i.SenderInfo.AccessGroupPublicKeyBase58Check:i.RecipientInfo.AccessGroupPublicKeyBase58Check;return await (0,er.L2)(t,s,i.MessageInfo.EncryptedText)}};class ey extends Error{constructor(e,t,i={}){super(e),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.assign(this,i),this.type=t,this.name="DeSoCoreError"}}let ep=e=>{let t=z.Wp.hexToBytes(e);return new TextDecoder().decode(t)}}}]);